// 문제요약
// n x n 의 보물지도를 만든다.
// arr1에는 숫자가 들어오는데 이진수로 풀어서 지도를 체크한다.
// arr2에도 숫자가 들어오는데 겹치는 부분을 모두 체크한다.
// 겹쳐진부분은 # 으로 표기하고 그 외에는 공백으로 풀어서 리턴한다.

// 입출력 예시 
// 5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28]
// => ["#####","# # #", "### #", "# ##", "#####"]
// 6, [46, 33, 33 ,22, 31, 50], [27 ,56, 19, 14, 14, 10]
// =>	["######", "### #", "## ##", " #### ", " #####", "### # "]

// ? 수도코드
// 배열 1과 2를 이진수로 변환한다.
// 5자리를 맞추기위해 0을 집어넣는다.
// 둘중 하나라도 1이 있으면 #으로 표시한다.

// 통과한 코드 (21.07.30)
function solution(n, arr1, arr2) {
  let answer = [];
  let check = '';

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (arr1[i].toString(2).padStart(n, "0")[j] === '1' || arr2[i].toString(2).padStart(n, "0")[j] === '1') {
        check = check + '#';
      } else {
        check = check + ' ';
      }
    }
    answer.push(check);
    check = '';
  }
  return answer;
}


// 실행코드
console.log(solution(5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28]));
console.log(solution(6, [46, 33, 33, 22, 31, 50], [27, 56, 19, 14, 14, 10]))

// 링크 : https://programmers.co.kr/learn/courses/30/lessons/17681